---
title: '게임 개발) FPS에 따라 속도 조정하기'
date:
    created: 2025-12-27T23:43:00
    updated: 2025-12-27T23:43:00
categories:
    - "코드 레시피"
tags:
    - 코드 레시피
    - 게임 개발
comments: true
---

# 게임 개발) 시간복잡도와 공간복잡도

특정 FPS에서 동작하던 코드를 더 높거나 낮은 FPS로 변경했을 때, 원본의 속도를 그대로 유지하려면 어떻게 해야할까요?

<!-- more -->

!!! note
    개인적으로 공부한 내용을 복습 겸 강좌 형식으로 작성한 글입니다.
    
    잘못된 정보와 오타 등이 포함되어 있을 수 있습니다.

## 서론

설정한 FPS에 따른 게임 속도와 변화율을 보정하는 방법에 대해 알아보기 전에, 사전 배경 지식을 조금만 보고 가봅시다.

FPS라는 단어... 많이 보고 들어보셨죠? 오늘 우리가 다룰 이 **FPS**가 무엇인지 아시나요?

보통 FPS라고 하면 흔하게 언급되는 두 가지가 있습니다. 초당 프레임 수를 의미하는 FPS와 1인칭 슈팅 게임을 의미하는 FPS입니다. 오늘 우리가 알아볼 것은 초당 프레임 수<sup style="color:gray">Frame Per Second</sup>를 의미하는 FPS입니다. 여기서, 프레임<sup style="color:gray">Frame</sup>은 정지된 이미지 한 장을 의미합니다.

!!! info "헤르츠"
    우리는 프레임이 발생하는 속도를 표기하기 위해 수 뒤에 FPS라는 단위를 수식합니다. '30FPS'라고 하면, 초당 프레임을 표시함을 의미합니다.

    뭐... 조금 더 엄밀하게(?) 따지자면 헤르츠<sup style="color:gray">Hz</sup>라는 단위가 있지만, 이 단위는 보통 모니터의 주사율을 표기할 때 사용하기 때문에 따로 구분지어 사용합니다.

## 고전 게임

아주 오래된 게임의 경우(대략적으로 2004년 이전쯤?) 지금처럼 하드웨어의 성능이 좋지 않았기 때문에 특정 FPS에서 동작하도록 만들어진 게임이 은근 있습니다. 그리고 이 게임을 현대에 와서 즐기려하면 여러가지 문제가 발생합니다. 호환성과 해상도는 나중 문제로 하고... 프레임 레이트가 낮기 때문에 화면이 툭툭 끊겨 보이고, 3D 게임을 하면 멀미를 유발합니다.

과거와는 다르게 현재는 하드웨어의 성능이 매우 좋아졌기 때문에 60FPS를 기반으로 하거나, 더 높은 FPS를 기반으로 개발합니다. FPS가 높으면 높을 수록 부드러운 화면 전환을 보여주기 때문에 멀미 유발도 덜하고 눈이 편해집니다.

!!! question "그래서 뭐가 문제죠?"
    굳이 먼 옛날 게임이 아니더라도 현재에도 특정 FPS에서 동작하도록 만들어진 게임이 있습니다. 왜냐하면 특정 하드웨어에 최적화된 속도 등이기 때문이죠.

    사실 게임을 즐기는 데 큰 문제는 없습니다. 다만, 이를 리메이크 또는 리마스터 작업을 수행할 때 조금 귀찮아집니다.

    과거에 비해 더 부드러운 화면 전환과 입력 처리를 보이기 위해 기대릴 품지 않고 FPS를 높였더니, 높인만큼 게임의 속도와 변화율이 매우 빨라지는 겁니다. 예를 들어, 30FPS에서 동작하던 수류탄 던지기 행동이 60FPS에선 2배 이상 빨라져 야구 투수로 변해버리는 것이죠. 144FPS에선 뭐 사실상 수류탄 총알이죠.

    무엇이 문제인지 아시겠나요? 특정 FPS를 기반으로 설계했기 때문에 그렇습니다. 즉, FPS가 변화함에 따른 보정을 수행하지 않았기 때문에 그렇습니다.

## 가산과 감산 연산
```cpp title="가산과_감산.cpp" linenums="1"
int32_t x = 1;
int32_t speed = 2;

// 대충 X축 이동 연산
if (Input::CheckKeyDown(RIGHT_ARROW)) {
    x += speed;
}
```

30FPS에서 동작하는 게임에서, 캐릭터의 X축을 이동시키기 위해 `#!cpp x += speed;` 연산을 수행한다고 해봅시다.

30FPS는 초당 30 프레임을 의미하고, 이는 1초가 30프레임이라는 것을 나타냅니다. 자, 위 코드를 정확히 1초(30프레임) 수행했을 때 `x`의 값은 얼마일까요?

간단한 질문을 해서 좀 그렇죠? `x`에 `speed`를 30번 더한 값이 최종값이 되겠죠? 공식으로 나타내면 `x + (speed * 30)`입니다. 즉, 최종값은 61이며, 1초 동안 60만큼 이동합니다.

자, 문제는 FPS가 변했을 때입니다. 60FPS와 144FPS로 높였을 때 값의 변화를 표로 확인해봅시다:

|시간(초)|30FPS|60FPS|144FPS|
|:-----|:-----|:-----|:-----|
|1|61|121|289|
|2|121|241|588|
|3|181|361|865|

30FPS에서 적당히 움직이던 캐릭터가 60FPS에선 우사인 볼트로, 144FPS에선 축지법을 쓰는 수준으로 변해버립니다.

### 델타타임

게임 개발을 조금이라도 접해보신 분들은 **델타타임**이라는 개념을 떠올리셨을 겁니다. 델타타임<sup style="color:gray">DeltaTime</sup>은 **두 연속된 프레임 간의 시간 간격**을 의미합니다.

하드웨어의 성능이 제각각인 PC 환경에선 프레임 드랍이 발생할 수 있고, 고사양 PC에선 훨씬 더 높은 프레임을 유지할 수 있습니다. 이럴 때 **모든 컴퓨터에서 동일한 게임 속도**를 보장하기 위해 사용하는 것이 델타타임입니다.

델타타임의 원리는 간단합니다. 프레임 사이의 시간 간격을 이동 속도에 곱해주면 끝입니다.

> 거리 = 속도 &times; 시간 이라는 물리 공식과도 같죠.

!!! info "델타타임 구하기"
    ```cpp title="calcDT.cpp" linenums="1"
    float currentTime = GetCurrentTime();           // 현재 시간
    float deltaTime = currentTime - lastTime;       // 현재 시간 - 이전 시간 = 경과 시간
    lastTime = currentTime;                         // 시간 갱신
    ```

    보통의 게임 엔진에선 기본으로 제공합니다. 직접 구현한다면 위와 같습니다.

    `Update()` 메서드 안에서 델타타임을 계속 구하면 됩니다.

!!! info "고정 델타타임"
    이상적인 상황이라면 `1.0 / FPS`가 델타타임이 됩니다. 프레임 드랍이 발생하지 않는 걸 보장할 수 있다면은요...
    
    |FPS|평균 델타타임 (초)|
    |:---|:---|
    |30FPS|0.033333|
    |60FPS|0.016667|
    |144FPS|0.006944|

### 주의할 점: 속도의 단위
자, 여기서 많은 분들이 실수하는 부분이 있습니다. 기존 코드를 델타 타임 방식으로 변경할 때 단순히 `deltaTime`만 곱하면 된다고 생각하는 것이죠.

기존 코드: `x += speed;` (speed가 2라고 가정)

수정 코드: `x += speed * deltaTime;`

이렇게 하면 어떻게 될까요?
30FPS 기준 `deltaTime`은 약 0.033입니다.
`x += 2 * 0.033` -> `x`는 1초(30프레임) 동안 약 2만큼 이동합니다.

어라? 아까는 1초에 60만큼 이동했는데 지금은 2밖에 이동을 안 하네요? **속도가 엄청나게 느려졌습니다.**

이유는 간단합니다. 기존의 `speed`는 **"프레임당 이동 거리"**였는데, 델타 타임 공식(`속도 * 시간`)에 들어가는 속도는 **"초당 이동 거리"**여야 하기 때문입니다.

따라서 델타 타임을 적용하려면 `speed` 변수의 값을 "초당 이동 거리"로 변환해주어야 합니다.
기존에 30FPS에서 한 프레임에 2만큼 이동했다면, 1초에는 `2 * 30 = 60`만큼 이동했을 것입니다.
즉, `newSpeed = speed * 30;` 으로 값을 재설정하고 `x += newSpeed * deltaTime;`을 해야 원래 속도와 같아집니다.

### 프레임 비율을 이용한 보정
만약 기존 코드의 수많은 상수(`speed` 같은 값들)를 일일이 "초당 단위"로 다시 계산해서 넣기 귀찮다면 어떻게 할까요?

이때 사용할 수 있는 것이 **프레임 비율**입니다. 거창한 건 아니고, "기준이 되는 FPS"를 "현재 FPS"로 나눈 값입니다.

`비율 = 기준_FPS / 현재_FPS`

예를 들어 30FPS를 기준으로 만든 게임(`BASE_FPS = 30`)을 60FPS 환경에서 돌린다면:
`Ratio = 30 / 60 = 0.5`

`x += speed * Ratio;`

이렇게 하면 60FPS에서는 `speed`의 절반만큼만 더해지지만, 프레임이 2배 더 자주 실행되므로 결과적으로 1초 동안 이동하는 거리는 같아집니다.

- 30FPS: `2`를 30번 더함 = 60
- 60FPS: `2 * 0.5(=1)`를 60번 더함 = 60

이 방식은 포팅 작업 시 기존 수치들을 그대로 유지하면서 FPS 가변성을 지원하고 싶을 때 유용합니다.

## 곱셈 연산 (A *= B)
```cpp linenums="1"
float x = 1.0f;
float speed = 1.01f;

x *= speed; // 매 프레임마다 1.01배씩 증가
```

이번에는 곱셈 연산입니다. 마찰력에 의한 감속이나, 가속도가 붙는 상황 등에서 자주 쓰입니다.
이 역시 FPS가 높아지면 연산 횟수가 많아져서 값이 기하급수적으로 변합니다.

|시간(초)|30FPS|60FPS|144FPS|
|:-----|:-----|:-----|:-----|
|1|1.34|1.81|4.19|
|2|1.81|3.30|17.56|
|3|2.44|5.99|73.59|

144FPS에서는 값이 폭주하고 있습니다.

### `pow()` 함수를 이용한 보정
단순 더하기(`+=`)는 비율을 그냥 곱하면 됐습니다. 하지만 곱하기(`*=`)를 여러 번 하는 건 **거듭제곱**의 영역입니다.

수학 시간이 되어버렸지만, 간단합니다.
30FPS에서 1.01을 1번 곱하는 것은, 60FPS에서 어떤 수(`Y`)를 2번 곱하는 것과 같아야 합니다.
`1.01 = Y * Y` -> `Y = sqrt(1.01)` -> `Y = 1.01^(0.5)`

즉, 여기서도 아까 구한 **비율(Ratio)**이 지수(Exponent)로 사용됩니다.

`x *= pow(speed, BASE_FPS / FPS);`

프로그래밍 언어의 `pow(밑, 지수)` 함수를 사용하면 됩니다.

- 30FPS: `pow(1.01, 30/30)` = `1.01` (그대로)
- 60FPS: `pow(1.01, 30/60)` = `1.00498...`

1.00498...을 60번 곱하면 1.01을 30번 곱한 것과 거의 근사한 값이 나옵니다.

이 방식을 사용하면 프레임 레이트가 변해도 물체의 감속비나 가속비를 일정하게 유지할 수 있습니다.

## 결론
FPS가 변해도 게임의 로직이 일정하게 동작하게 하려면 "시간"을 기준으로 생각해야 합니다.

1.  **새로 만드는 게임**: **델타 타임**을 무조건 사용하세요. 모든 속도 변수는 "초당 이동 거리"로 정의하세요.
2.  **기존 게임 포팅**: 값을 일일이 바꾸기 힘들다면 **프레임 비율(`Base / Current`)**을 활용하세요.
    -   더하기 연산: `val += speed * Ratio`
    -   곱하기 연산: `val *= pow(factor, Ratio)`

이렇게 하면 어떤 주사율의 모니터에서도 쾌적하게 돌아가는 게임을 만들 수 있습니다!
