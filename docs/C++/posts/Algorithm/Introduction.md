---
title: 'C++ 알고리즘) 알고리즘'
date:
    created: 2025-12-01T22:28:00
    updated: 2025-12-18T21:00:00
categories:
    - 알고리즘
tags:
    - 알고리즘
comments: true
---

# C++ 알고리즘) 알고리즘

어떤 문제를 해결하기 위해 따라야하는 절차 또는 방법, 알고리즘에 대해 알아봅시다.

<!-- more -->

!!! note
    개인적으로 공부한 내용을 복습 겸 강좌 형식으로 작성한 글입니다.
    
    잘못된 정보와 오타 등이 포함되어 있을 수 있습니다.

## 알고리즘이란?

**"알 수 없는 알고리즘이 나를 여기로 이끌었다..."**{: .text-gradient }

알고리즘이라는 단어, 일상에서 자주 보고 듣지만 막상 정확히 무엇인지 설명하기 쉽지 않습니다.

대부분의 사람들은(?) 알고리즘을 **유튜브 추천 시스템**이나 **복잡한 수학 공식** 정도로 생각하거나 이해합니다.

그런데, 그거 아시나요? 알고리즘은 생각보다 훨씬 간단하고, 친근한 녀석이라는 것을요.

컴퓨터 과학이나 그외 전문가가 아니더라도 우리는 매일 알고리즘을 알게 모르게 사용하고 있습니다.

## 알고리즘

알고리즘<sup style="color:gray">Algorithm</sup>은 어떤 문제를 해결하기 위해 **정해진 순서대로 따라야하는 절차 또는 방법**을 의미합니다.


<div class="grid cards" markdown>

-   **요리할 때**

    ---

    1.  물 550ml를 끓인다.
    2.  면과 스프를 넣는다.
    3.  5분간 끓인다.
    4.  완성

-   **출퇴근할 때**

    ---

    1.  목적지까지 이동 가능한 경로 파악
    2.  각 경로의 시간과 비용 비교
    3.  최적의 경로 선택
    4.  이동

</div>

이처럼 우리는 일상 생활 속에서 자연스럽게 알고리즘을 사용하며 살아가고 있습니다.

### 좋은 알고리즘의 조건

|조건|의미|
|:-----|:-----|
|명확성(Clarity)|각 단계는 모호하지 않고, 명확해야 합니다.|
|유한성(Finiteness)|반드시 종료가 되어야 합니다. 무한 반복되어선 안 됩니다.|
|효율성(Effectiveness)|실행 가능하고 효율적이어야 합니다.|
|입력(Input)|0개 이상의 입력이 있어야 합니다.|
|출력(Output)|1개 이상의 결과를 만들어야 합니다.|

!!! question "왜 알고리즘을 배워야하나요?"
    같은 문제라도 **어떤 알고리즘을 사용하느냐**에 따라 10초 걸리던 작업이 0.01초로 줄어들 수 있고, 10GB의 메모리가 필요한 작업이 100MB로 줄어드는 것이 가능해집니다.

    알고리즘의 공부는 더 나은 해결책을 찾는 능력을 기르는 데 도움을 줍니다.

### 예제

> **문제**: 1부터 50까지의 합을 구하세요.

간단한 예제로 알고리즘의 중요성에 대해 알아봅시다.

1부터 50까지의 합을 구하는 건 간단해 보이지만, 이 문제를 **어떻게 해결하느냐**에 따라 효율성이 천차만별입니다.

#### 방법 1) 브루트 포스

1부터 50까지의 합을 구하는 가장 직관적인 방법은 **처음부터 끝까지 하나씩 더하는 것**입니다.

이를 전문 용어로(?) 브루트 포스<sup style="color:gray">Brute Force</sup>라고 합니다. 직역하면 **무식하게 힘으로** 해결한다는 뜻입니다.

시간과 자원이 엄청나게 들기 때문에 비효율적인 것은 사실이지만, 반드시 답을 도출한다는 것과 직관적이다라는 장점이 있습니다.

**1부터 50까지의 합을 구하는 과정**{: .pointDot }

| 과정       | 합    | 과정        | 합     |
| :--------- | :---- | :---------- | :----- |
| $1 + 2$    | $3$   | $325 + 26$  | $351$  |
| $3 + 3$    | $6$   | $351 + 27$  | $378$  |
| $6 + 4$    | $10$  | $378 + 28$  | $406$  |
| $10 + 5$   | $15$  | $406 + 29$  | $435$  |
| $15 + 6$   | $21$  | $435 + 30$  | $465$  |
| $21 + 7$   | $28$  | $465 + 31$  | $496$  |
| $28 + 8$   | $36$  | $496 + 32$  | $528$  |
| $36 + 9$   | $45$  | $528 + 33$  | $561$  |
| $45 + 10$  | $55$  | $561 + 34$  | $595$  |
| $55 + 11$  | $66$  | $595 + 35$  | $630$  |
| $66 + 12$  | $78$  | $630 + 36$  | $666$  |
| $78 + 13$  | $91$  | $666 + 37$  | $703$  |
| $91 + 14$  | $105$ | $703 + 38$  | $741$  |
| $105 + 15$ | $120$ | $741 + 39$  | $780$  |
| $120 + 16$ | $136$ | $780 + 40$  | $820$  |
| $136 + 17$ | $153$ | $820 + 41$  | $861$  |
| $153 + 18$ | $171$ | $861 + 42$  | $903$  |
| $171 + 19$ | $190$ | $903 + 43$  | $946$  |
| $190 + 20$ | $210$ | $946 + 44$  | $990$  |
| $210 + 21$ | $231$ | $990 + 45$  | $1035$ |
| $231 + 22$ | $253$ | $1035 + 46$ | $1081$ |
| $253 + 23$ | $276$ | $1081 + 47$ | $1128$ |
| $276 + 24$ | $300$ | $1128 + 48$ | $1176$ |
| $300 + 25$ | $325$ | $1176 + 49$ | $1225$ |
|            |       | $1225 + 50$ | $1275$ |

어떤가요? 확실하게 정답을 구할 수 있는 확신의 알고리즘이지만... 덧셈을 49번이나 진행해야 합니다.

시간복잡도를 계산하면 $O(N)$입니다. N에 비례하여 연산 횟수가 증가하기 때문입니다.

이 방식은 정확하지만 생각보다 비효율적인 알고리즘입니다. 왜냐하면, 요즘의 PC는 성능이 좋아서 계산이 빠르다곤 하지만, 코딩 테스트에는 시간제한이 존재하기 때문에 이 알고리즘을 택하는 건 어리석은 선택일 지도 모릅니다.

#### 방법 2) 💡 가우스의 덧셈

더 효율적인 방법이 있을까요? **있습니다!!!**

1부터 50까지의 수를 자세히 관찰해봅시다:

```text title="1부터 50까지의 수"
첫 번째와 마지막 : 1 + 50 = 51
두 번째와 끝에서 둘 : 2 + 49 = 51
세 번째와 끝에서 셋 : 3 + 48 = 51
⋮
중간의 두 수 : 25 + 26 = 51
```

잘 보시면 패턴이 보이지 않나요? 양 끝에서 시작해 짝을 지으면 항상 **51**이 됩니다.

즉, 각 쌍의 합과 쌍의 개수를 곱하면 1부터 50까지의 합이 도출됩니다.

<div class="grid cards" markdown>

-   **계산**

    ---

    - 쌍의 개수: $50 \div 2 = 25$개
    - 각 쌍의 합 : $51$
    - 전체 합: $51 \times 25 = 1,275$

</div>

$$ S = \frac{N \times (N + 1)}{2} $$

수학 공식으로 나타내면 위와 같습니다.

가우스 덧셈의 방식은 브루트 포스 방식와는 다르게 곱셈과 나눗셈 연산만으로 바로 합을 구할 수 있습니다. N의 값이 10,000이든, 1,000,000이든 연산의 횟수는 동일하며, 시간복잡도는 $O(1)$이 됩니다.

!!! quote "가우스 일화"
    독일의 수학자 카를 프리드리히 가우스(Carl Friedrich Gauss)는 초등학생 시절, 선생님이 **"1부터 100까지 더하세요"**라는 벌칙을(?) 내렸을 때, 이 패턴을 발견하고 단 몇 초 만에 **5,050**이라는 답을 제시했다는 유명한 일화가 있습니다.

#### 두 방식 비교

| 구분           | 방법 1(브루트 포스) | 방법 2(가우스 덧셈)     |
| :------------- | :------------------ | :---------------------- |
| **연산 횟수**  | N의 비례            | 3번(곱셈, 덧셈, 나눗셈) |
| **시간복잡도** | $O(N)$              | $O(1)$                  |
| **효율성**     | 낮음                | 높음                    |

같은 문제라도 어떤 알고리즘을 사용하느냐에 따라 효율성이 달라집니다.

#### 구현

```cpp title="1부터 N까지의 합.cpp" linenums="1"
#include <iostream>

int main(int argc, char* argv[]) {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);

    // N 입력
    int N; std::cin >> N;

    // 방법 1) 브루트 포스
    int sum1 = 0;
    for (int i = 1; i <= N; ++i) {
        sum1 += i;
    }

    // 방법 2) 가우스 덧셈
    int sum2 = (N * (N + 1)) / 2;

    std::cout << "방법 1의 결과: " << sum1 << '\n';
    std::cout << "방법 2의 결과: " << sum2 << '\n';

    return 0;
}
```

```bash title="입력"
50
```

```bash title="출력"
방법 1의 결과: 1275
방법 2의 결과: 1275
```

----------

## 마무리

지금까지 간단한 예제로 알고리즘의 중요성을 봤습니다.

알고리즘은 단순한 코딩 기술이 아니며, 문제 해결 능력을 기르는 과정입니다.

앞으로의 알고리즘을 배울 때 손으로 직접 과정을 써내려가며 이해해보는 것이 중요합니다.

----------

## 연습 문제
### ⭐ [백준 8393번 - 합](https://www.acmicpc.net/problem/8393)

N이 주어졌을 때, 1부터 N까지의 합을 구하는 문제입니다.

난이도는 매우 낮은 편에 속합니다. 오늘 우리가 배운 방법 1과 방법 2를 사용하면 해결할 수 있습니다.