---
title: 'C++ 알고리즘) 시간복잡도와 공간복잡도'
date:
    created: 2025-12-02T22:48:00
    updated: 2025-12-19T00:01:00
categories:
    - 알고리즘
tags:
    - 알고리즘
    - 시간복잡도
    - 공간복잡도
comments: true
---

# C++ 알고리즘) 시간복잡도와 공간복잡도

알고리즘의 효율성을 판단할 수 있는, 시간복잡도와 공간복잡도에 대해 알아봅시다.

<!-- more -->

!!! note
    개인적으로 공부한 내용을 복습 겸 강좌 형식으로 작성한 글입니다.
    
    잘못된 정보와 오타 등이 포함되어 있을 수 있습니다.

## 서론

**"이 알고리즘이 더 빠를까, 저 알고리즘이 더 빠를까?"**{: .text-gradient }

알고리즘을 비교할 때 가장 먼저 마주하는 질문입니다. 여러분은 알고리즘의 효율성을 무엇으로 판단하실건가요? 실행 시간?

단언컨데, "내 컴퓨터에서 0.1초만에 실행됐어"와 같은 건 의미가 없습니다. 왜 그럴까요?

사실 알고리즘의 실행 시간은 컴퓨터의 성능에 따라 결과가 달라지고, 컴파일러 최적화 옵션에 따라 차이가 크기 때문입니다. 심지어 CPU의 온도, 그날의 습도, 기운(?) 등에 따라 달라지기도 합니다.

그래서 우리에게 필요한 건 **상대적이고 객관적인 평가 기준**입니다. 그것이 바로 오늘 배울 시간복잡도와 공간복잡도입니다.

본 글에서는 수학적인 증명보다, 시간복잡도와 공간복잡도의 이해에 포커스를 두었습니다. 이론적인 부분은 다소 부족합니다.

### 💡 알고갑시다!

복잡도 이야기를 진행할 때 **로그**라는 단어를 자주 접하게 됩니다. 로그<sup style="color:gray">Log</sup>란, 어떤 수를 몇 번 제곱해야 우리가 알고 싶은 수가 되는 지를 구해주는 함수입니다.

자세히 말하자면, 밑<sup style="color:gray">Base, Radix</sup>을 2로 가질 때 몇 제곱을 해야 우리가 원하는 수 $x$가 나올까를 말합니다. 이를 $\log_2{x}$로 표기합니다.

컴퓨터 과학에서 로그를 언급하면 대부분 밑이 2라는 것으로 알고 있으시면 되겠습니다.

**예시**{: .pointDot }

1.  8은 2를 몇 번 제곱해야 나올까? &rarr; $log_2{(8)} = 3$
2.  32는 2를 몇 번 제곱해야 나올까? &rarr; $log_2{(32)} = 5$

----------

## ⏱ 시간복잡도 (Time Complexity)

**왜 '초'가 아닌 '횟수'일까?**{: .pointBar }

실행 시간은 하드웨어에 의존적이기 때문에 절대적인 기준이 될 수 없습니다. 따라서, 우리는 **입력 크기 N이 변할 때 연산 횟수가 어떻게/얼마나 증가하는 가**를 봐야합니다.

### 예시

1,000 페이지를 가진 전화번호부에서 '신창섭'을 찾는다고 해봅시다.

방법은 여러가지가 있겠지만, 우리는 브루트 포스와 이진 탐색을 알고 있다는 가정 하에 읽어봅시다.

#### 방법 1) 브루트 포스

브루트 포스는 [이전 게시글](./Introduction.md/#1)에서 설명했듯, 데이터가 주어지면 처음부터 끝까지 탐색하는 것입니다.

이 방식은 **운이 좋으면 첫 페이지에서**, **운이 나쁘면 끝 페이지**에서 발견할 수 있습니다. 평균적으론 약 500번 확인해야 하죠.

#### 방법 2) 이진 탐색

이진 탐색은 데이터를 절반씩 나누면서 찾는 방식입니다. 이 방식은 이후에 배울 **정렬**이 되어있다는 가정 하에 올바르게 작동합니다.

1.  책의 절반인 500 페이지를 펼친 후, 앞과 뒤를 볼 지 판단합니다.
2.  앞 (250 페이지) 또는 뒤 (750 페이지)를 펼칩니다.
3.  계속 절반씩 나누며 찾습니다.

1,000 페이지 기준으로 $\log{(1000)} \approx 10$번 안에 찾아낼 수 있습니다.

----------

전화번호부가 1,000에서 10,000으로 늘어났다고 해봅시다.

브루트 포스 방식의 경우 평균 5,000번을 확인해야하고, 이진 탐색의 경우 약 14번 정도만 확인하면 됩니다.

결국 중요한 것은 내 알고리즘이 몇 초나 걸리느냐가 아닌, **입력의 크기가 커졌을 때 얼마나 살아남을 수 있는가**입니다. 이것이 시간복잡도의 핵심입니다.

----------

## Big-O 표기법

Big-O('빅오'라 발음)는 입력 크기 N이 커졌을 때, 연산 횟수의 증가 추세를 나타내는 표기법입니다.

즉, **대략 이러한 패턴으로 느려진다**라는 것을 표현합니다.

### 핵심 규칙

1.  **최고차항만 남긴다**{: .pointColor }

    입력 크기 N이 매우 클 때 낮은 차수는 무의미해지기 때문에, 최고차항<sub style="color:gray">다항식에서 지수가 가장 큰 항</sub>만을 남깁니다.

    -   $5N^2 + 100N + 1000 = O(N^2)$
    -   $3N^3 + 2N^2 + N = O(N^3)$
    -   $N \log N + N = O(N \log N)$

    | N     | $5N^2$    | $100N$  | 1000  | 합        |
    | :---- | :-------- | :------ | :---- | :-------- |
    | 10    | 500       | 1,000   | 1,000 | 2,500     |
    | 100   | 50,000    | 10,000  | 1,000 | 61,000    |
    | 1,000 | 5,000,000 | 100,000 | 1,000 | 5,101,000 |

    N의 값이 커질 수록 $N^2$의 항이 압도적인 걸 확인할 수 있습니다. 그래서 최고차항만을 남긴다는 것입니다.

2.  **계수(상수)는 무시한다**{: .pointColor }

    Big-O는 증가 추세를 보는 것일 뿐, 정확한 값을 도출해내고자 하는 게 아닙니다.

    - $5N = O(N)$
    - $1000N = O(N)$
    - $0.001N^2 = O(N^2)$

    물론... $O(N)$이어도 계수가 10,000이라면 느릴 수 있습니다. 하지만, Big-O는 큰 그림을 보는 표기법이기 때문에 크게 신경쓰지 않으셔도 됩니다.

3.  **최악의 경우를 기반으로 한다**{: .pointColor }

    Big-O는 최악의 경우를 기반으로 합니다. 왜 그럴까요?

    알고리즘 대회나 실무에선 '운이 좋아서 빨리 끝나는 경우'가 없기 때문입니다. 데이터가 꼬일 대로 꼬였을 때(최악의 테스트 케이스) 제한 시간 안에 실행할 수 있어야 안심할 수 있습니다. 그래서 Big-O는 **일종의 상한선<sup style="color:gray">Upper Bound</sup>**{: .dynamic-highlight }을 보장해 줍니다.

    ```cpp title="특정 값 찾는 로직.cpp" linenums="1"
    for (int i = 0; i < N; ++i) {
        if (Arr[i] == targetNumber) {
            return i;
        }
    }
    ```

    배열에서 특정 값(`targetNumber`)을 찾는 로직입니다.

    - 최선: 바로 발견 ($O(1)$)
    - 평균: 중간 발견 ($O(N \div 2)$)
    - **최악: 끝에 있거나 없음 ($O(N)$)** &rarr; 이것이 Big-O

### 주요 시간복잡도
#### $O(1)$ - 상수 시간

```cpp
// 배열의 첫 번째 원소 접근
int firstElement = Arr[0];

// 해시맵에서 값 찾기
auto it = hMap.find(key);       // 평균적으로 O(1)

// 수학 공식: 아래는 가우스 덧셈
int sum = (N * (N + 1)) / 2;
```

입력 크기와는 무관하게 일정한 시간복잡도를 가집니다.

엘리베이터의 층 버튼 중 어떤 걸 눌러도 누르는 시간은 같은 것과 같습니다.

#### $O(\log N)$ - 로그 시간

```cpp
int binarySearch(const std::vector<int>& arr, int targetNumber) {
    int left = 0, right = arr.size() - 1;

    while (left <= right) {
        int mid (left + right) >> 1;

        if (arr[mid] == targetNumber) return mid;
        else if (arr[mid] < targetNumber) left = mid + 1;
        else right = mid - 1;
    }

    return -1;
}
```

문제를 절반씩 줄여나간다는 특징을 갖고 있습니다.

- $N = 100$ &rarr; 약 7번
- $N = 1,000$ &rarr; 약 10번
- $N = 1,000,000$ &rarr; 약 20번

#### $O(N)$ - 선형 시간

```cpp
// 배열 순회
int sum = 0;
for (int i = 0; i < N; ++i) {
    sum += Arr[i];
}
```

입력 크기 N에 정비례하며, N이 10배 커지면 시간도 10배로 늘어납니다.

#### $O(N \log N)$ - 선형 로그 시간

```cpp
// 퀵, 병합, 힙 정렬
std::sort(arr.begin(), arr.end());
```

보통 효율적인 정렬 알고리즘들의 시간복잡도입니다.

- $N = 100$ &rarr; 약 664번
- $N = 1,000$ &rarr; 약 9,966번
- $N = 10,000$ &rarr; 약 132,877번

#### $O(N^2)$ - 제곱 시간

```cpp
// 버블 정렬
for (int i = 0; i < N - 1; ++i) {
    for (int j = 0; j < N - i - 1; ++j) {
        if (arr[j] > arr[j + 1]) {
            arr[j] ^= arr[j + 1] ^= arr[j] ^= arr[j + 1];
        }
    }
}
```

대표적으로 이중 반복문을 사용할 때입니다. N이 10배 증가하면, 시간은 100배 증가합니다.

반에 있는 학생들이 서로 한 명씩 악수하는 경우를 생각하시면 되겠습니다.

#### $O(2^N)$ - 지수 시간

```cpp
int fibo(int n) {
    if (n <= 1) return n;

    return fibo(n - 1) * fibo(n - 2);
}
```

N이 1씩 증가할 때 마다 시간은 2배씩 늘어납니다.

- $N = 10$ &rarr; 1,024번
- $N = 20$ &rarr; 1,048,576번

#### $O(N!)$ - 팩토리얼 시간

```cpp
void tsp(int n) {
    // ...
}
```

모든 순열을 탐색하거나, 외판원 문제를 풀이할 때 나타나는 대표적인 시간복잡도입니다.

- $N = 5$ &rarr; 120번
- $N = 10$ &rarr; 3,628,800번

### 시간복잡도 비교 표

| N    | $O(1)$ | $O(\log N)$ | $O(N)$ | $O(N \log N)$ | $O(N^2)$ | $O(2^N)$ | $O(N!)$   |
| :--- | :----- | :---------- | :----- | :------------ | :------- | :------- | :-------- |
| 1    | 1      | 0           | 1      | 0             | 1        | 2        | 1         |
| 10   | 1      | 3           | 10     | 33            | 100      | 1,024    | 3,628,800 |
| 100  | 1      | 7           | 100    | 664           | 10,000   | 죽여줘   | 사망      |

- $O(N^2)$은 $N \le 10,000$ 정도에서 사용 가능합니다.
- $O(2^N)$은 많이 봐줘서 $N \le 30$이 한계입니다.
- $O(N!)$은 $N \le 10$이 한계입니다.

----------

## 🥅 공간복잡도 (Space Complexity)

시간복잡도는 '얼마나 느려지냐'라면, 공간복잡도는 '얼마나 많은 메모리를 쳐먹냐'입니다. 표기법은 시간복잡도와 동일하게 Big-O 표기법을 사용합니다.

요즘은 워낙에 메모리가 넉넉한 시대라... 시간복잡도에 비해 덜 중요하게 여겨지기도 합니다. 하지만, 코딩 테스트 문제에선 메모리 제한을 하는 경우가 많기 때문에 무턱대고 큰 배열 등을 선언했다간 MLE<sup style="color:gray">Memory Limit Exceeded</sup>(메모리 초과)를 영접할 수 있습니다.

### 공간복잡도 표

| 코드 상황              | 공간복잡도 | 설명                                     |
| :--------------------- | :--------- | :--------------------------------------- |
| `#!cpp int a`                | $O(1)$     | 입력 크기와 상관없이 변수 몇 개만 사용   |
| `#!cpp std::vector<int> vec` | $O(N)$     | 데이터의 개수만큼 배열(메모리) 공간 필요 |
| `#!cpp int arr[N][N]`        | $O(N^2)$   | 그래프 인접 행렬, 2차원 DP 테이블 등     |

!!! warning "재귀 깊이"
    재귀 함수를 사용할 때 스택 메모리가 쌓입니다.

    재귀의 깊이가 N만큼 깊어지면, 그만큼 공간복잡도도 $O(N)$이 됩니다.

----------

## 시간-공간 트레이드 오프 (Time-Space Trade-Off)

메모리를 더 쓰면 시간을 줄일 수 있고, 메모리를 아끼면 시간이 더 걸린다.

이것이 바로 **시간과 공간의 등가교환** 개념입니다.

### 예시
#### 피보나치 수열
**방법 1: 순수 재귀**{: .pointDot }
```cpp title="피보나치 재귀" linenums="1"
int fibo(int n) {
    if (n <= 1) return n;
    return fibo(n - 1) + fibo(n - 2);
}
```
$$ fibo(5) = fibo(4) + fibo(3) = (fibo(3) + fibo(2)) + (fibo(2) + fibo(1)) = \ldots $$

$fibo(3)$과 $fibo(2)$가 여러번 계산되는 걸 확인할 수 있습니다. 같은 값을 반복 계산하는 중복되는 경우죠.

메모리는 덜 사용하지만, 시간은 더 오래걸리는 나쁜 케이스입니다.

**방법 2: 메모이제이션**{: .pointDot }
```cpp title="피보나치 재귀 + 메모이제이션" linenums="1"
int memo[100];

int fibo(int n) {
    if (n <= 1) return n;
    if (memo[n] != -1) return memo[n];          // 이미 계산된 값이라면, 반환

    return memo[n] = fibo(n - 1) + fibo(n - 2);
}
```

방법 1은 같은 값을 몇 번이고 다시 계산한다는 단점이 있습니다. 이를 해결하기 위해 메모이제이션<sup style="color:gray">Memoization</sup> 기법을 도입한 것입니다.

계산한 값을 별도의 배열에 저장한 후, 계산된 값이라면 해당 값에 접근하여 반환해버리는 것입니다.

메모리를 더 사용하여 시간을 더 절약하는 방법이죠. 별도의 배열과 재귀 스택으로 인해 공간복잡도는 $O(N)$입니다.

대신에 시간복잡도는 $O(N)$으로 훨씬 빨라집니다.

**방법 3: 반복문**{: .pointDot }
```cpp title="피보나치 반복문" linenums="1"
int fibo(int n) {
    if (n <= 1) return n;
    
    int prev2 = 0, prev1 = 1;
    for (int i = 2; i <= n; ++i) {
        int current = prev1 + prev2;
        prev2 = prev1;
        prev1 = current;
    }
    return prev1;
}
```

메모리를 최소로 사용하고, 반복문을 이용하여 빠르게 계산합니다.

변수는 딸랑 3개만 사용되기 때문에 공간복잡도는 $O(1)$이며, 시간복잡도는 $O(N)$입니다.

### 그래서 어떤 기준으로 해야할까?

일반적인 우선순위는 '시간', '메모리' 순입니다.

시간 제한이 빡빡한 편이라면 메모리를 희생하여 메모이제이션과 DP 기법을 이용하는 것이 좋고, 메모리 제한이 빡빡한 경우라면 시간을 희생시킵니다.

----------

## 마무리

시간복잡도와 공간복잡도는 알고리즘의 효율성을 판단하는 가장 중요한 도구입니다.

처음에는 코드 로직의 복잡도를 계산하는 게 쉽지 않기 때문에 단순하게 접근해보세요. 반복문이 1개면 $O(N)$, 2개면 $O(N^2)$처럼 말이죠. 그리고 N이 커지면 내 코드는 얼마나 느려질 지 생각합니다.

처음에 대략적으로 생각하고, 점점 정교해지면 됩니다.

### 시간복잡도의 핵심

- 실행 시간이 아닌 **증가 추세**
- 최고차항만을 남기고, 계수는 무시한다.
- 최악의 경우를 기준으로 한다.

**주요 시간복잡도**{: .pointDot }

| 시간복잡도    | 이름      | N = 1,000 | 사용 예시          |
| :------------ | :-------- | :-------- | :----------------- |
| $O(1)$        | 상수      | 1         | 배열 접근, 수식 등 |
| $O(\log N)$   | 로그      | 10        | 이진 탐색 등       |
| $O(N)$        | 선형      | 1,000     | 순회, 탐색 등      |
| $O(N \log N)$ | 선형 로그 | 10,000    | 정렬 등            |
| $O(N^2)$      | 제곱      | 1,000,000 | 이중 반복문 등     |
| $O(2^N)$      | 지수      | 사망      | 조합 등            |
| $O(N!)$       | 팩토리얼  | 끔살      | 팩토리얼 등        |

### 공간복잡도의 핵심

- 코딩 테스트 문제에서 제공하는 메모리 제한 반드시 확인
- 재귀 호출 시 깊이 주의
- 필요한 만큼만 할당해서 사용

----------

## 연습 문제
### ⭐ [백준 15552번 - 빠른 A+B](https://www.acmicpc.net/problem/15552)

입출력 최적화의 중요성에 대해 알 수 있습니다.

### ⭐⭐⭐ [백준 - 시간복잡도](https://www.acmicpc.net/step/53)

시간복잡도 관련 문제가 있는 모음입니다.